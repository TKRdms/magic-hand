<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Particle</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; color: white; }
        
        #loading {
            position: fixed; inset: 0; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100;
        }

        /* Perbaikan untuk warning VS Code kamu */
        .rainbow-text {
            background-image: linear-gradient(to left, violet, rgb(193, 150, 224), rgb(88, 88, 212), rgb(98, 223, 98), rgb(236, 236, 112), rgb(245,rgb(201, 75, 75)9, 113), rgb(255, 98, 98));
            -webkit-background-clip: text; /* Vendor prefix */
            background-clip: text;         /* Standard property - Ini yang bikin warning hilang */
            color: transparent;
            font-weight: bold;
        }

        #status-bar {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            padding: 10px 25px; border-radius: 30px; background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2);
            z-index: 10; font-size: 14px; letter-spacing: 1px;
        }

        #video-container {
            position: fixed; bottom: 20px; right: 20px; width: 180px; height: 135px;
            border: 2px solid rgba(0, 255, 255, 0.4); border-radius: 12px; 
            overflow: hidden; transform: scaleX(-1);
        }

        #debug-info { color: #ff4444; font-size: 12px; margin-top: 10px; font-family: monospace; }
    </style>
</head>
<body>

<div id="loading">
    <h2 class="rainbow-text">INITIALIZING...</h2>
    <p>izinkan akses kamera di browser</p>
    <div id="debug-info"></div>
</div>

<div id="status-bar">MODE: <span id="gesture-name" class="rainbow-text">MENUNGGU TANGAN...</span></div>

<div id="video-container">
    <video id="input-video" playsinline style="width:100%; height:100%; object-fit:cover;"></video>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
import * as THREE from 'three';

const config = { particleCount: 30000, returnSpeed: 0.07, damping: 0.92 };
let scene, camera, renderer, points, geometry, targets, velocities, positions;
let handLandmarks = null;
let currentShape = 'sphere';

const log = (msg) => document.getElementById('debug-info').innerText = msg;

// Generator Bentuk
function createShape(type) {
    const arr = new Float32Array(config.particleCount * 3);
    if (type === 'heart' || type === 'ily') {
        const cvs = document.createElement('canvas');
        const ctx = cvs.getContext('2d');
        cvs.width = 400; cvs.height = 200;
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.font = type === 'heart' ? 'bold 150px Arial' : 'bold 50px Arial';
        ctx.fillText(type === 'heart' ? '‚ù§' : 'I LOVE YOU', 200, 150);
        
        const pixels = ctx.getImageData(0,0,400,200).data;
        const pts = [];
        for(let i=0; i<pixels.length; i+=4) {
            if(pixels[i] > 200) {
                pts.push({ x: ((i/4)%400 - 200)*0.09, y: (100 - Math.floor((i/4)/400))*0.09 });
            }
        }
        for(let i=0; i<config.particleCount; i++) {
            const p = pts[i % pts.length];
            arr[i*3] = p.x; arr[i*3+1] = p.y; arr[i*3+2] = (Math.random()-0.5);
        }
    } else {
        for(let i=0; i<config.particleCount; i++) {
            const phi = Math.acos(-1 + (2*i)/config.particleCount);
            const theta = Math.sqrt(config.particleCount * Math.PI) * phi;
            arr[i*3] = 7 * Math.cos(theta) * Math.sin(phi);
            arr[i*3+1] = 7 * Math.sin(theta) * Math.sin(phi);
            arr[i*3+2] = 7 * Math.cos(phi);
        }
    }
    return arr;
}

async function start() {
    try {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        geometry = new THREE.BufferGeometry();
        positions = new Float32Array(config.particleCount * 3);
        velocities = new Float32Array(config.particleCount * 3);
        const colors = new Float32Array(config.particleCount * 3);
        targets = createShape('sphere');

        for(let i=0; i<config.particleCount; i++) {
            positions[i*3] = (Math.random()-0.5)*50;
            const c = new THREE.Color().setHSL(i/config.particleCount, 1, 0.5);
            colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        points = new THREE.Points(geometry, new THREE.PointsMaterial({
            size: 0.07, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
        }));
        scene.add(points);

        // AI Setup
        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7});
        hands.onResults(res => {
            if(res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                handLandmarks = res.multiHandLandmarks[0];
                document.getElementById('loading').style.display = 'none';
                updateGesture();
            }
        });

        const video = document.getElementById('input-video');
        const cam = new Camera(video, {
            onFrame: async () => await hands.send({image: video}),
            width: 640, height: 480
        });
        cam.start().catch(e => log("Kamera Error: Pastikan klik 'Allow'"));

        renderLoop();
    } catch(e) { log("Fatal Error: " + e.message); }
}

function updateGesture() {
    const tip = (i) => handLandmarks[i];
    const up = (i, base) => tip(i).y < tip(base).y;
    
    let label = "IDLE";
    if (up(8,6) && up(12,10) && !up(16,14)) { label = "‚úåÔ∏è LOVE"; targets = createShape('heart'); }
    else if (up(4,2) && !up(8,6)) { label = "üëç SPHERE"; targets = createShape('sphere'); }
    else if (up(8,6) && up(20,18) && !up(12,10)) { label = "ü§ü I LOVE YOU"; targets = createShape('ily'); }
    else if (up(8,6) && up(12,10) && up(16,14)) { label = "üñêÔ∏è EXPLODE"; }
    else if (!up(8,6) && !up(12,10)) { label = "‚úä BLACK HOLE"; }
    
    document.getElementById('gesture-name').innerText = label;
}

function renderLoop() {
    requestAnimationFrame(renderLoop);
    const pos = geometry.attributes.position.array;
    const label = document.getElementById('gesture-name').innerText;

    let hX = 0, hY = 0;
    if(handLandmarks) {
        hX = (0.5 - handLandmarks[9].x) * 40;
        hY = (0.5 - handLandmarks[9].y) * 25;
    }

    for(let i=0; i<config.particleCount; i++) {
        const i3 = i * 3;
        velocities[i3] += (targets[i3] - pos[i3]) * config.returnSpeed * 0.1;
        velocities[i3+1] += (targets[i3+1] - pos[i3+1]) * config.returnSpeed * 0.1;

        if(handLandmarks) {
            const dx = pos[i3] - hX, dy = pos[i3+1] - hY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(label.includes("üñêÔ∏è") && dist < 6) { velocities[i3] += dx/dist * 0.5; velocities[i3+1] += dy/dist * 0.5; }
            else if(label.includes("‚úä")) { velocities[i3] += (hX - pos[i3]) * 0.1; velocities[i3+1] += (hY - pos[i3+1]) * 0.1; }
        }

        pos[i3] += velocities[i3]; pos[i3+1] += velocities[i3+1];
        velocities[i3] *= config.damping; velocities[i3+1] *= config.damping;
    }
    geometry.attributes.position.needsUpdate = true;
    points.rotation.y += 0.002;
    renderer.render(scene, camera);
}

start();
</script>
</body>
</html>